package com.github.microwww.bitcoin.script;

import com.github.microwww.bitcoin.chain.RawTransaction;
import com.github.microwww.bitcoin.chain.TxOut;
import com.github.microwww.bitcoin.util.ByteUtil;
import com.github.microwww.bitcoin.util.ClassPath;
import com.github.microwww.bitcoin.wallet.Secp256k1;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

/**
 * https://en.bitcoin.it/wiki/OP_CHECKSIG
 * OP_CHECKSIG çš„ demo !
 */
public class ScriptTest {

    @Test
    public void opCheckSig() {
        ByteBuf ss = Unpooled.buffer();
        // blk number 170, tx 1, input 0
        // version = 1
        ss.writeIntLE(1);
        // 1 inputs
        ss.writeByte(1);

        // input 0
        // prevout hash
        int[] v = new int[]{0x04, 0x37, 0xcd, 0x7f, 0x85, 0x25, 0xce, 0xed, 0x23, 0x24, 0x35, 0x9c, 0x2d, 0x0b, 0xa2, 0x60, 0x06, 0xd9, 0x2d, 0x85, 0x6a, 0x9c, 0x20, 0xfa, 0x02, 0x41, 0x10, 0x6e, 0xe5, 0xa5, 0x97, 0xc9};
        for (int i = 0; i < v.length; i++) {
            ss.writeByte(v[v.length - 1 - i]);
        }
        // prevout index
        ss.writeIntLE(0);

        // input script after running OP_CHECKSIG for this tx is a single
        // OP_CHECKSIG opcode
        //data_chunk raw_data;
        int[][] raw_script = new int[4][];
        int[] raw_data = {0x04, 0x11, 0xdb, 0x93, 0xe1, 0xdc, 0xdb, 0x8a, 0x01, 0x6b, 0x49, 0x84, 0x0f, 0x8c, 0x53, 0xbc, 0x1e, 0xb6, 0x8a, 0x38, 0x2e, 0x97, 0xb1, 0x48, 0x2e, 0xca, 0xd7, 0xb1, 0x48, 0xa6, 0x90, 0x9a, 0x5c, 0xb2, 0xe0, 0xea, 0xdd, 0xfb, 0x84, 0xcc, 0xf9, 0x74, 0x44, 0x64, 0xf8, 0x2e, 0x16, 0x0b, 0xfa, 0x9b, 0x8b, 0x64, 0xf9, 0xd4, 0xc0, 0x3f, 0x99, 0x9b, 0x86, 0x43, 0xf6, 0x56, 0xb4, 0x12, 0xa3};
        int len = raw_data.length;
        raw_script[2] = raw_data;
        raw_script[1] = new int[]{raw_data.length};
        len++;
        // libbitcoin::extend_data (raw_script, raw_data);
        raw_script[3] = new int[]{172};
        len++;
        raw_script[0] = new int[]{len};
        for (int[] ints : raw_script) {
            for (int anInt : ints) {
                ss.writeByte(anInt);
            }
        }
        // sequence
        ss.writeIntLE(0xffffffff);

        // 2 outputs for this tx
        ss.writeByte(2);

        // output 0
        ss.writeLongLE(1000000000);
        // script for output 0
        raw_data = new int[]{0x04, 0xae, 0x1a, 0x62, 0xfe, 0x09, 0xc5, 0xf5, 0x1b, 0x13, 0x90, 0x5f, 0x07, 0xf0, 0x6b, 0x99, 0xa2, 0xf7, 0x15, 0x9b, 0x22, 0x25, 0xf3, 0x74, 0xcd, 0x37, 0x8d, 0x71, 0x30, 0x2f, 0xa2, 0x84, 0x14, 0xe7, 0xaa, 0xb3, 0x73, 0x97, 0xf5, 0x54, 0xa7, 0xdf, 0x5f, 0x14, 0x2c, 0x21, 0xc1, 0xb7, 0x30, 0x3b, 0x8a, 0x06, 0x26, 0xf1, 0xba, 0xde, 0xd5, 0xc7, 0x2a, 0x70, 0x4f, 0x7e, 0x6c, 0xd8, 0x4c};
        // when data < 75, we can just write it's length as a single byte ('special'
        // opcodes)
        raw_script[2] = raw_data;
        len = raw_data.length;
        raw_script[1] = new int[]{len};
        len++;
        //raw_script = data_chunk();
        //raw_script.push_back(raw_data.size());
        //libbitcoin::extend_data (raw_script, raw_data);
        // OP_CHECKSIG
        raw_script[3] = new int[]{172};
        len++;
        // now actually write the script
        raw_script[0] = new int[]{len};//(raw_script.size());

        for (int[] ints : raw_script) {
            for (int anInt : ints) {
                ss.writeByte(anInt);
            }
        }

        // output 1
        ss.writeLongLE(4000000000L);
        // script for output 0
        raw_data = new int[]{0x04, 0x11, 0xdb, 0x93, 0xe1, 0xdc, 0xdb, 0x8a, 0x01, 0x6b, 0x49, 0x84, 0x0f, 0x8c, 0x53, 0xbc, 0x1e, 0xb6, 0x8a, 0x38, 0x2e, 0x97, 0xb1, 0x48, 0x2e, 0xca, 0xd7, 0xb1, 0x48, 0xa6, 0x90, 0x9a, 0x5c, 0xb2, 0xe0, 0xea, 0xdd, 0xfb, 0x84, 0xcc, 0xf9, 0x74, 0x44, 0x64, 0xf8, 0x2e, 0x16, 0x0b, 0xfa, 0x9b, 0x8b, 0x64, 0xf9, 0xd4, 0xc0, 0x3f, 0x99, 0x9b, 0x86, 0x43, 0xf6, 0x56, 0xb4, 0x12, 0xa3};
        // when data < 75, we can just write it's length as a single byte ('special'
        ss.writeByte(raw_data.length + 2);
        ss.writeByte(raw_data.length);
        for (int raw_datum : raw_data) {
            ss.writeByte(raw_datum);
        }
        // OP_CHECKSIG
        ss.writeByte(172);

        // End of 2 outputs

        // locktime
        ss.writeIntLE(0);

        // write hash_type_code
        ss.writeIntLE(1);

        // Dump hex to screen

        int[] raw_tx = {0x01, 0x00, 0x00, 0x00, 0x01, 0xc9, 0x97, 0xa5, 0xe5, 0x6e, 0x10, 0x41, 0x02, 0xfa, 0x20, 0x9c, 0x6a, 0x85, 0x2d, 0xd9, 0x06, 0x60, 0xa2, 0x0b, 0x2d, 0x9c, 0x35, 0x24, 0x23, 0xed, 0xce, 0x25, 0x85, 0x7f, 0xcd, 0x37, 0x04, 0x00, 0x00, 0x00, 0x00, 0x43, 0x41, 0x04, 0x11, 0xdb, 0x93, 0xe1, 0xdc, 0xdb, 0x8a, 0x01, 0x6b, 0x49, 0x84, 0x0f, 0x8c, 0x53, 0xbc, 0x1e, 0xb6, 0x8a, 0x38, 0x2e, 0x97, 0xb1, 0x48, 0x2e, 0xca, 0xd7, 0xb1, 0x48, 0xa6, 0x90, 0x9a, 0x5c, 0xb2, 0xe0, 0xea, 0xdd, 0xfb, 0x84, 0xcc, 0xf9, 0x74, 0x44, 0x64, 0xf8, 0x2e, 0x16, 0x0b, 0xfa, 0x9b, 0x8b, 0x64, 0xf9, 0xd4, 0xc0, 0x3f, 0x99, 0x9b, 0x86, 0x43, 0xf6, 0x56, 0xb4, 0x12, 0xa3, 0xac, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0xca, 0x9a, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x43, 0x41, 0x04, 0xae, 0x1a, 0x62, 0xfe, 0x09, 0xc5, 0xf5, 0x1b, 0x13, 0x90, 0x5f, 0x07, 0xf0, 0x6b, 0x99, 0xa2, 0xf7, 0x15, 0x9b, 0x22, 0x25, 0xf3, 0x74, 0xcd, 0x37, 0x8d, 0x71, 0x30, 0x2f, 0xa2, 0x84, 0x14, 0xe7, 0xaa, 0xb3, 0x73, 0x97, 0xf5, 0x54, 0xa7, 0xdf, 0x5f, 0x14, 0x2c, 0x21, 0xc1, 0xb7, 0x30, 0x3b, 0x8a, 0x06, 0x26, 0xf1, 0xba, 0xde, 0xd5, 0xc7, 0x2a, 0x70, 0x4f, 0x7e, 0x6c, 0xd8, 0x4c, 0xac, 0x00, 0x28, 0x6b, 0xee, 0x00, 0x00, 0x00, 0x00, 0x43, 0x41, 0x04, 0x11, 0xdb, 0x93, 0xe1, 0xdc, 0xdb, 0x8a, 0x01, 0x6b, 0x49, 0x84, 0x0f, 0x8c, 0x53, 0xbc, 0x1e, 0xb6, 0x8a, 0x38, 0x2e, 0x97, 0xb1, 0x48, 0x2e, 0xca, 0xd7, 0xb1, 0x48, 0xa6, 0x90, 0x9a, 0x5c, 0xb2, 0xe0, 0xea, 0xdd, 0xfb, 0x84, 0xcc, 0xf9, 0x74, 0x44, 0x64, 0xf8, 0x2e, 0x16, 0x0b, 0xfa, 0x9b, 0x8b, 0x64, 0xf9, 0xd4, 0xc0, 0x3f, 0x99, 0x9b, 0x86, 0x43, 0xf6, 0x56, 0xb4, 0x12, 0xa3, 0xac, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00};
        byte[] vv = getBytes(raw_tx);
        assertArrayEquals(vv, ByteUtil.readAll(ss));


        byte[] tx_hash = ByteUtil.sha256sha256(vv); //libbitcoin::generate_sha256_hash (ss.get_data());

        int[] pubkey = {
                0x04, 0x11, 0xdb, 0x93, 0xe1, 0xdc, 0xdb, 0x8a, 0x01, 0x6b, 0x49, 0x84, 0x0f, 0x8c, 0x53, 0xbc, 0x1e, 0xb6, 0x8a, 0x38, 0x2e, 0x97, 0xb1, 0x48, 0x2e, 0xca, 0xd7, 0xb1, 0x48, 0xa6, 0x90, 0x9a, 0x5c, 0xb2, 0xe0, 0xea, 0xdd, 0xfb, 0x84, 0xcc, 0xf9, 0x74, 0x44, 0x64, 0xf8, 0x2e, 0x16, 0x0b, 0xfa, 0x9b, 0x8b, 0x64, 0xf9, 0xd4, 0xc0, 0x3f, 0x99, 0x9b, 0x86, 0x43, 0xf6, 0x56, 0xb4, 0x12, 0xa3
        };
        // Leave out last byte since that's the hash_type_code (SIGHASH_ALL in this
        // case)
        int[] signature = {
                0x30, 0x44, 0x02, 0x20, 0x4e, 0x45, 0xe1, 0x69, 0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1, 0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6, 0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd, 0x41, 0x02, 0x20, 0x18, 0x15, 0x22, 0xec, 0x8e, 0xca, 0x07, 0xde, 0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90, 0x9d, 0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22, 0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09
        };
        assertEquals(signature.length, 70);

        boolean b = Secp256k1.signatureVerify(getBytes(pubkey), getBytes(signature), tx_hash);
        assertTrue(b);
    }

    private byte[] getBytes(int[] raw_tx) {
        byte[] vv = new byte[raw_tx.length];
        for (int i = 0; i < raw_tx.length; i++) {
            vv[i] = (byte) raw_tx[i];
        }
        return vv;
    }

    @Test
    public void test_OP_1() {
        ByteBuf bf = Unpooled.buffer();

        RawTransaction tx = new RawTransaction();
        {
            byte[] hex = ByteUtil.hex("01000000018ac66537aa8ee407a4dd9cf7e233256d6238693672e42b12ae4ba50bd6709936000000000151ffffffff0100000000000000001976a91401c26a20bf282a099cbc113d3b66669b8e28899088ac00000000");
            tx.read(bf.clear().writeBytes(hex));
            assertEquals(tx.hash().toHexReverse256(), "3a5e0977cc64e601490a761d83a4ea5be3cd03b0ffb73f5fe8be6507539be76c");
        }
        RawTransaction from = new RawTransaction();
        {
            byte[] hex = ByteUtil.hex(ClassPath.readClassPathFile("/data/online.data.txt").get(34));
            bf.writeBytes(hex);
            from.read(bf);
            assertEquals(from.hash().toHexReverse256(), "369970d60ba54bae122be472366938626d2533e2f79cdda407e48eaa3765c68a");
        }
        int in = 0;
        assertEquals(tx.getTxIns()[in].getPreTxHash(), from.hash());
        TxOut txOut = from.getTxOuts()[tx.getTxIns()[in].getPreTxOutIndex()];
        Interpreter interpreter = new Interpreter(tx).indexTxIn(in, txOut)//.witnessPushStack()
                .executor(tx.getTxIns()[in].getScript())
                .executor(txOut.getScriptPubKey());
        assertTrue(interpreter.isSuccess());
    }

    @Test
    public void test_OP_CHECKMULTISIG_6a26d2ecb67f27d1f() {
        ByteBuf bf = Unpooled.buffer();

        RawTransaction tx = new RawTransaction();
        {
            byte[] hex = ByteUtil.hex("0100000001f6ea284ec7521f8a7d094a6cf4e6873098b90f90725ffd372b343189d7a4089c0100000026255121029b6d2c97b8b7c718c325d7be3ac30f7c9d67651bce0c929f55ee77ce58efcf8451aeffffffff0130570500000000001976a9145a3acbc7bbcc97c5ff16f5909c9d7d3fadb293a888ac00000000");
            tx.read(bf.clear().writeBytes(hex));
            assertEquals(tx.hash().toHexReverse256(), "6a26d2ecb67f27d1fa5524763b49029d7106e91e3cc05743073461a719776192");
        }
        RawTransaction from = new RawTransaction();
        {
            byte[] hex = ByteUtil.hex("010000000168781ca236d8e70e4af8285852defabeff61c73db259cbbbebdf7bdac918c234010000004847304402206d186984373e0b781b85f49334cc9a249ffd13a448a5d1732096b011a10063e102206d280df8f4b5e6805f48eb04601ca6d97edd78f2b2d1104dc577e08fd788c78001ffffffff02cce80900000000001976a914fe58bbf690824bdaffb0431a709c27d7bdb6105e88ac801a06000000000017a91419a7d869032368fd1f1e26e5e73a4ad0e474960e8700000000");
            bf.writeBytes(hex);
            from.read(bf);
            assertEquals(from.hash().toHexReverse256(), "9c08a4d78931342b37fd5f72900fb9983087e6f46c4a097d8a1f52c74e28eaf6");
        }
        int in = 0;
        assertEquals(tx.getTxIns()[in].getPreTxHash(), from.hash());
        TxOut txOut = from.getTxOuts()[tx.getTxIns()[in].getPreTxOutIndex()];
        Interpreter interpreter = new Interpreter(tx, 0).indexTxIn(in, txOut)//.witnessPushStack()
                .executor(tx.getTxIns()[in].getScript())
                .executor(txOut.getScriptPubKey());
        assertTrue(interpreter.isSuccess());

        try {
            new Interpreter(tx, 200_000).indexTxIn(in, txOut)//.witnessPushStack()
                    .executor(tx.getTxIns()[in].getScript())
                    .executor(txOut.getScriptPubKey());
            fail();
        } catch (Exception e) {
        }
    }
}
